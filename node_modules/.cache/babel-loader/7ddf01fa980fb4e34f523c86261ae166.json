{"remainingRequest":"/Users/erwangoudard/Desktop/Projet Test Technique/Projet Test Technique/node_modules/babel-loader/lib/index.js!/Users/erwangoudard/Desktop/Projet Test Technique/Projet Test Technique/node_modules/vuetify/lib/util/mergeData.js","dependencies":[{"path":"/Users/erwangoudard/Desktop/Projet Test Technique/Projet Test Technique/node_modules/vuetify/lib/util/mergeData.js","mtime":499162500000},{"path":"/Users/erwangoudard/Desktop/Projet Test Technique/Projet Test Technique/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/erwangoudard/Desktop/Projet Test Technique/Projet Test Technique/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:InVzZSBzdHJpY3QiOwoKT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICJfX2VzTW9kdWxlIiwgewogIHZhbHVlOiB0cnVlCn0pOwpleHBvcnRzLmRlZmF1bHQgPSBtZXJnZURhdGE7CmV4cG9ydHMubWVyZ2VTdHlsZXMgPSBtZXJnZVN0eWxlczsKZXhwb3J0cy5tZXJnZUNsYXNzZXMgPSBtZXJnZUNsYXNzZXM7CmV4cG9ydHMubWVyZ2VMaXN0ZW5lcnMgPSBtZXJnZUxpc3RlbmVyczsKCnZhciBfaGVscGVycyA9IHJlcXVpcmUoIi4vaGVscGVycyIpOwoKY29uc3QgcGF0dGVybiA9IHsKICBzdHlsZUxpc3Q6IC87KD8hW14oXSpcKSkvZywKICBzdHlsZVByb3A6IC86KC4qKS8KfTsKCmZ1bmN0aW9uIHBhcnNlU3R5bGUoc3R5bGUpIHsKICBjb25zdCBzdHlsZU1hcCA9IHt9OwoKICBmb3IgKGNvbnN0IHMgb2Ygc3R5bGUuc3BsaXQocGF0dGVybi5zdHlsZUxpc3QpKSB7CiAgICBsZXQgW2tleSwgdmFsXSA9IHMuc3BsaXQocGF0dGVybi5zdHlsZVByb3ApOwogICAga2V5ID0ga2V5LnRyaW0oKTsKCiAgICBpZiAoIWtleSkgewogICAgICBjb250aW51ZTsKICAgIH0gLy8gTWF5IGJlIHVuZGVmaW5lZCBpZiB0aGUgYGtleTogdmFsdWVgIHBhaXIgaXMgaW5jb21wbGV0ZS4KCgogICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7CiAgICAgIHZhbCA9IHZhbC50cmltKCk7CiAgICB9CgogICAgc3R5bGVNYXBbKDAsIF9oZWxwZXJzLmNhbWVsaXplKShrZXkpXSA9IHZhbDsKICB9CgogIHJldHVybiBzdHlsZU1hcDsKfQoKZnVuY3Rpb24gbWVyZ2VEYXRhKCkgewogIGNvbnN0IG1lcmdlVGFyZ2V0ID0ge307CiAgbGV0IGkgPSBhcmd1bWVudHMubGVuZ3RoOwogIGxldCBwcm9wOyAvLyBBbGxvdyBmb3IgdmFyaWFkaWMgYXJndW1lbnQgbGVuZ3RoLgoKICB3aGlsZSAoaS0tKSB7CiAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIGRhdGEgcHJvcGVydGllcyBhbmQgZXhlY3V0ZSBtZXJnZSBzdHJhdGVnaWVzCiAgICAvLyBPYmplY3Qua2V5cyBlbGltaW5hdGVzIG5lZWQgZm9yIGhhc093blByb3BlcnR5IGNhbGwKICAgIGZvciAocHJvcCBvZiBPYmplY3Qua2V5cyhhcmd1bWVudHNbaV0pKSB7CiAgICAgIHN3aXRjaCAocHJvcCkgewogICAgICAgIC8vIEFycmF5IG1lcmdlIHN0cmF0ZWd5IChhcnJheSBjb25jYXRlbmF0aW9uKQogICAgICAgIGNhc2UgJ2NsYXNzJzoKICAgICAgICBjYXNlICdkaXJlY3RpdmVzJzoKICAgICAgICAgIGlmIChhcmd1bWVudHNbaV1bcHJvcF0pIHsKICAgICAgICAgICAgbWVyZ2VUYXJnZXRbcHJvcF0gPSBtZXJnZUNsYXNzZXMobWVyZ2VUYXJnZXRbcHJvcF0sIGFyZ3VtZW50c1tpXVtwcm9wXSk7CiAgICAgICAgICB9CgogICAgICAgICAgYnJlYWs7CgogICAgICAgIGNhc2UgJ3N0eWxlJzoKICAgICAgICAgIGlmIChhcmd1bWVudHNbaV1bcHJvcF0pIHsKICAgICAgICAgICAgbWVyZ2VUYXJnZXRbcHJvcF0gPSBtZXJnZVN0eWxlcyhtZXJnZVRhcmdldFtwcm9wXSwgYXJndW1lbnRzW2ldW3Byb3BdKTsKICAgICAgICAgIH0KCiAgICAgICAgICBicmVhazsKICAgICAgICAvLyBTcGFjZSBkZWxpbWl0ZWQgc3RyaW5nIGNvbmNhdGVuYXRpb24gc3RyYXRlZ3kKCiAgICAgICAgY2FzZSAnc3RhdGljQ2xhc3MnOgogICAgICAgICAgaWYgKCFhcmd1bWVudHNbaV1bcHJvcF0pIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CgogICAgICAgICAgaWYgKG1lcmdlVGFyZ2V0W3Byb3BdID09PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgbWVyZ2VUYXJnZXRbcHJvcF0gPSAnJzsKICAgICAgICAgIH0KCiAgICAgICAgICBpZiAobWVyZ2VUYXJnZXRbcHJvcF0pIHsKICAgICAgICAgICAgLy8gTm90IGFuIGVtcHR5IHN0cmluZywgc28gY29uY2F0ZW5hdGUKICAgICAgICAgICAgbWVyZ2VUYXJnZXRbcHJvcF0gKz0gJyAnOwogICAgICAgICAgfQoKICAgICAgICAgIG1lcmdlVGFyZ2V0W3Byb3BdICs9IGFyZ3VtZW50c1tpXVtwcm9wXS50cmltKCk7CiAgICAgICAgICBicmVhazsKICAgICAgICAvLyBPYmplY3QsIHRoZSBwcm9wZXJ0aWVzIG9mIHdoaWNoIHRvIG1lcmdlIHZpYSBhcnJheSBtZXJnZSBzdHJhdGVneSAoYXJyYXkgY29uY2F0ZW5hdGlvbikuCiAgICAgICAgLy8gQ2FsbGJhY2sgbWVyZ2Ugc3RyYXRlZ3kgbWVyZ2VzIGNhbGxiYWNrcyB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheSwKICAgICAgICAvLyBzbyB0aGF0IHRoZSBsYXN0IGRlZmluZWQgY2FsbGJhY2sgd2lsbCBiZSBpbnZva2VkIGZpcnN0LgogICAgICAgIC8vIFRoaXMgaXMgZG9uZSBzaW5jZSB0byBtaW1pYyBob3cgT2JqZWN0LmFzc2lnbiBtZXJnaW5nCiAgICAgICAgLy8gdXNlcyB0aGUgbGFzdCBnaXZlbiB2YWx1ZSB0byBhc3NpZ24uCgogICAgICAgIGNhc2UgJ29uJzoKICAgICAgICBjYXNlICduYXRpdmVPbic6CiAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldW3Byb3BdKSB7CiAgICAgICAgICAgIG1lcmdlVGFyZ2V0W3Byb3BdID0gbWVyZ2VMaXN0ZW5lcnMobWVyZ2VUYXJnZXRbcHJvcF0sIGFyZ3VtZW50c1tpXVtwcm9wXSk7CiAgICAgICAgICB9CgogICAgICAgICAgYnJlYWs7CiAgICAgICAgLy8gT2JqZWN0IG1lcmdlIHN0cmF0ZWd5CgogICAgICAgIGNhc2UgJ2F0dHJzJzoKICAgICAgICBjYXNlICdwcm9wcyc6CiAgICAgICAgY2FzZSAnZG9tUHJvcHMnOgogICAgICAgIGNhc2UgJ3Njb3BlZFNsb3RzJzoKICAgICAgICBjYXNlICdzdGF0aWNTdHlsZSc6CiAgICAgICAgY2FzZSAnaG9vayc6CiAgICAgICAgY2FzZSAndHJhbnNpdGlvbic6CiAgICAgICAgICBpZiAoIWFyZ3VtZW50c1tpXVtwcm9wXSkgewogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KCiAgICAgICAgICBpZiAoIW1lcmdlVGFyZ2V0W3Byb3BdKSB7CiAgICAgICAgICAgIG1lcmdlVGFyZ2V0W3Byb3BdID0ge307CiAgICAgICAgICB9CgogICAgICAgICAgbWVyZ2VUYXJnZXRbcHJvcF0gPSB7IC4uLmFyZ3VtZW50c1tpXVtwcm9wXSwKICAgICAgICAgICAgLi4ubWVyZ2VUYXJnZXRbcHJvcF0KICAgICAgICAgIH07CiAgICAgICAgICBicmVhazsKICAgICAgICAvLyBSZWFzc2lnbm1lbnQgc3RyYXRlZ3kgKG5vIG1lcmdlKQoKICAgICAgICBkZWZhdWx0OgogICAgICAgICAgLy8gc2xvdCwga2V5LCByZWYsIHRhZywgc2hvdywga2VlcEFsaXZlCiAgICAgICAgICBpZiAoIW1lcmdlVGFyZ2V0W3Byb3BdKSB7CiAgICAgICAgICAgIG1lcmdlVGFyZ2V0W3Byb3BdID0gYXJndW1lbnRzW2ldW3Byb3BdOwogICAgICAgICAgfQoKICAgICAgfQogICAgfQogIH0KCiAgcmV0dXJuIG1lcmdlVGFyZ2V0Owp9CgpmdW5jdGlvbiBtZXJnZVN0eWxlcyh0YXJnZXQsIHNvdXJjZSkgewogIGlmICghdGFyZ2V0KSByZXR1cm4gc291cmNlOwogIGlmICghc291cmNlKSByZXR1cm4gdGFyZ2V0OwogIHRhcmdldCA9ICgwLCBfaGVscGVycy53cmFwSW5BcnJheSkodHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycgPyBwYXJzZVN0eWxlKHRhcmdldCkgOiB0YXJnZXQpOwogIHJldHVybiB0YXJnZXQuY29uY2F0KHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnID8gcGFyc2VTdHlsZShzb3VyY2UpIDogc291cmNlKTsKfQoKZnVuY3Rpb24gbWVyZ2VDbGFzc2VzKHRhcmdldCwgc291cmNlKSB7CiAgaWYgKCFzb3VyY2UpIHJldHVybiB0YXJnZXQ7CiAgaWYgKCF0YXJnZXQpIHJldHVybiBzb3VyY2U7CiAgcmV0dXJuIHRhcmdldCA/ICgwLCBfaGVscGVycy53cmFwSW5BcnJheSkodGFyZ2V0KS5jb25jYXQoc291cmNlKSA6IHNvdXJjZTsKfQoKZnVuY3Rpb24gbWVyZ2VMaXN0ZW5lcnModGFyZ2V0LCBzb3VyY2UpIHsKICBpZiAoIXRhcmdldCkgcmV0dXJuIHNvdXJjZTsKICBpZiAoIXNvdXJjZSkgcmV0dXJuIHRhcmdldDsKICBsZXQgZXZlbnQ7CgogIGZvciAoZXZlbnQgb2YgT2JqZWN0LmtleXMoc291cmNlKSkgewogICAgLy8gQ29uY2F0IGZ1bmN0aW9uIHRvIGFycmF5IG9mIGZ1bmN0aW9ucyBpZiBjYWxsYmFjayBwcmVzZW50LgogICAgaWYgKHRhcmdldFtldmVudF0pIHsKICAgICAgLy8gSW5zZXJ0IGN1cnJlbnQgaXRlcmF0aW9uIGRhdGEgaW4gYmVnaW5uaW5nIG9mIG1lcmdlZCBhcnJheS4KICAgICAgdGFyZ2V0W2V2ZW50XSA9ICgwLCBfaGVscGVycy53cmFwSW5BcnJheSkodGFyZ2V0W2V2ZW50XSk7CiAgICAgIHRhcmdldFtldmVudF0ucHVzaCguLi4oMCwgX2hlbHBlcnMud3JhcEluQXJyYXkpKHNvdXJjZVtldmVudF0pKTsKICAgIH0gZWxzZSB7CiAgICAgIC8vIFN0cmFpZ2h0IGFzc2lnbi4KICAgICAgdGFyZ2V0W2V2ZW50XSA9IHNvdXJjZVtldmVudF07CiAgICB9CiAgfQoKICByZXR1cm4gdGFyZ2V0Owp9"},{"version":3,"sources":["../../src/util/mergeData.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @copyright 2017 Alex Regan\n * @license MIT\n * @see https://github.com/alexsasharegan/vue-functional-data-merge\n */\n/* eslint-disable max-statements */\nimport { VNodeData } from 'vue'\nimport { camelize, wrapInArray } from './helpers'\n\nconst pattern = {\n  styleList: /;(?![^(]*\\))/g,\n  styleProp: /:(.*)/,\n} as const\n\nfunction parseStyle (style: string) {\n  const styleMap: Dictionary<any> = {}\n\n  for (const s of style.split(pattern.styleList)) {\n    let [key, val] = s.split(pattern.styleProp)\n    key = key.trim()\n    if (!key) {\n      continue\n    }\n    // May be undefined if the `key: value` pair is incomplete.\n    if (typeof val === 'string') {\n      val = val.trim()\n    }\n    styleMap[camelize(key)] = val\n  }\n\n  return styleMap\n}\n\n/**\n * Intelligently merges data for createElement.\n * Merges arguments left to right, preferring the right argument.\n * Returns new VNodeData object.\n */\nexport default function mergeData (...vNodeData: VNodeData[]): VNodeData\nexport default function mergeData (): VNodeData {\n  const mergeTarget: VNodeData & Dictionary<any> = {}\n  let i: number = arguments.length\n  let prop: string\n\n  // Allow for variadic argument length.\n  while (i--) {\n    // Iterate through the data properties and execute merge strategies\n    // Object.keys eliminates need for hasOwnProperty call\n    for (prop of Object.keys(arguments[i])) {\n      switch (prop) {\n        // Array merge strategy (array concatenation)\n        case 'class':\n        case 'directives':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeClasses(mergeTarget[prop], arguments[i][prop])\n          }\n          break\n        case 'style':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeStyles(mergeTarget[prop], arguments[i][prop])\n          }\n          break\n        // Space delimited string concatenation strategy\n        case 'staticClass':\n          if (!arguments[i][prop]) {\n            break\n          }\n          if (mergeTarget[prop] === undefined) {\n            mergeTarget[prop] = ''\n          }\n          if (mergeTarget[prop]) {\n            // Not an empty string, so concatenate\n            mergeTarget[prop] += ' '\n          }\n          mergeTarget[prop] += arguments[i][prop].trim()\n          break\n        // Object, the properties of which to merge via array merge strategy (array concatenation).\n        // Callback merge strategy merges callbacks to the beginning of the array,\n        // so that the last defined callback will be invoked first.\n        // This is done since to mimic how Object.assign merging\n        // uses the last given value to assign.\n        case 'on':\n        case 'nativeOn':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeListeners(mergeTarget[prop], arguments[i][prop])\n          }\n          break\n        // Object merge strategy\n        case 'attrs':\n        case 'props':\n        case 'domProps':\n        case 'scopedSlots':\n        case 'staticStyle':\n        case 'hook':\n        case 'transition':\n          if (!arguments[i][prop]) {\n            break\n          }\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = {}\n          }\n          mergeTarget[prop] = { ...arguments[i][prop], ...mergeTarget[prop] }\n          break\n        // Reassignment strategy (no merge)\n        default: // slot, key, ref, tag, show, keepAlive\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = arguments[i][prop]\n          }\n      }\n    }\n  }\n\n  return mergeTarget\n}\n\nexport function mergeStyles (\n  target: undefined | string | object[] | object,\n  source: undefined | string | object[] | object\n) {\n  if (!target) return source\n  if (!source) return target\n\n  target = wrapInArray(typeof target === 'string' ? parseStyle(target) : target)\n\n  return (target as object[]).concat(typeof source === 'string' ? parseStyle(source) : source)\n}\n\nexport function mergeClasses (target: any, source: any) {\n  if (!source) return target\n  if (!target) return source\n\n  return target ? wrapInArray(target).concat(source) : source\n}\n\nexport function mergeListeners (\n  target: { [key: string]: Function | Function[] } | undefined,\n  source: { [key: string]: Function | Function[] } | undefined\n) {\n  if (!target) return source\n  if (!source) return target\n\n  let event: string\n\n  for (event of Object.keys(source)) {\n    // Concat function to array of functions if callback present.\n    if (target[event]) {\n      // Insert current iteration data in beginning of merged array.\n      target[event] = wrapInArray(target[event])\n      ;(target[event] as Function[]).push(...wrapInArray(source[event]))\n    } else {\n      // Straight assign.\n      target[event] = source[event]\n    }\n  }\n\n  return target\n}\n"],"sourceRoot":""}]}